import { Options, prettyPrint } from "recast";
import { builders as b, ASTNode, namedTypes } from "ast-types";
import { ASTBuildError } from "../Errors";
import { LiteralTypes, CodeUnitObject, CodeUnitArray, ObjectType } from "../../types/utils";
import { isObject, isArray } from "./typeGuards";

// used for specify types for code generated by ast
export type CodeUnitType = CodeUnitString
    | CodeUnitNumber | CodeUnitBoolean | CodeUnitNull
    | CodeUnitUndefined | CodeUnitObj | CodeUnitArr
    | CodeUnitVar;
interface CodeUnitString {
    __type__: 'string';
    value: string;
}
interface CodeUnitNumber {
    __type__: 'number';
    value: number;
}
interface CodeUnitBoolean {
    __type__: 'boolean';
    value: boolean;
}
interface CodeUnitNull {
    __type__: 'null';
    value: null;
}
interface CodeUnitUndefined {
    __type__: 'undefined';
    value: undefined;
}
interface CodeUnitObj {
    __type__: 'obj';
    value: CodeUnitObject;
}
interface CodeUnitArr {
    __type__: 'arr';
    value: CodeUnitArray;
}
interface CodeUnitVar {
    __type__: 'var';
    value: string;
}

export type CodeUnitTypes = CodeUnitType['__type__'];


export const toSource = (node: ASTNode, opts: Options = {}): string => {
    return prettyPrint(node, opts).code;
};

// TODO: 将 LiteralType、CodeUnitTypes 数组提取出配置
export const LiteralTypeList: string[] = ['string', 'number', 'boolean', 'null'];
export const CodeUnitTypeList: string[] = ['string', 'number', 'boolean', 'null', 'var', 'undefined', 'obj', 'arr'];

export const isLiteralType = (arg: string) => LiteralTypeList.includes(arg);

export const isInCodeUnitType = (arg: string) => CodeUnitTypeList.includes(arg);

// it doesn't validate whether the value's type is match the arg.__type__
export const isCodeUnit = (arg: any): arg is CodeUnitType => {
    return isObject(arg) && isInCodeUnitType(arg.__type__) && ('value' in arg);
};

export const isLiterals = (arg: any): arg is LiteralTypes => {
    return typeof(arg) === 'string' || typeof(arg) === 'boolean' ||
        typeof(arg) === 'number' || arg === null;
};

export function buildNodeFromCodeUnit(cu: CodeUnitType) {
    switch (cu.__type__) {
        case 'string':
            return b.literal(String(cu.value));
        case 'number':
            return b.literal(Number(cu.value));
        case 'boolean':
            return b.literal(Boolean(cu.value));
        case 'null':
            return b.literal(null);
        case 'var':
            return b.identifier(cu.value);
        case 'undefined':
            return b.identifier('undefined');
        case 'obj':
            return buildNodeFromObject(cu.value);
        case 'arr':
            return buildArrayNodeFromArray(cu.value);
        default:
            throw new ASTBuildError(`Unknown CodeUnit type ${(cu as any).__type__}`);
    }
}

/**
 * build an array of ast node from an array of config
 * @param arr 
 */
export function buildNodesFromArray(arr: CodeUnitArray): 
    (namedTypes.ObjectExpression | namedTypes.Literal |
    namedTypes.Identifier | namedTypes.ArrayExpression)[]
{
    return arr.map((ele) => {
        if (isLiterals(ele)) {
            return b.literal(ele);
        }
        if (isCodeUnit(ele)) {
            return buildNodeFromCodeUnit(ele);
        }
        if (isObject(ele)) {
            return buildNodeFromObject(ele);
        }
        if (isArray(ele)) {
            return buildArrayNodeFromArray(ele);
        }
        throw new ASTBuildError(`can not process type ${typeof ele}`);
    });
}

/**
 * build an ArrayExpression ast node from an array of config
 */
export const buildArrayNodeFromArray = (arr: CodeUnitArray) => b.arrayExpression(buildNodesFromArray(arr));

export function buildProperty(key: string, value: any) {
    return b.property(
        'init',
        b.literal(key),
        value
    );
}

/**
 * build object ast node
 * @param obj 
 */
export function buildNodeFromObject(obj: ObjectType):
    namedTypes.ObjectExpression | namedTypes.Literal |
    namedTypes.Identifier | namedTypes.ArrayExpression
{
    if (isCodeUnit(obj)) return buildNodeFromCodeUnit(obj);
    
    const properties = [];
    for (let k in obj) {
        const v = obj[k];
        if (isLiterals(v)) {
            properties.push(
                buildProperty(k, b.literal(v))
            );
        }
        else if (isCodeUnit(v)) {
            properties.push(
                buildProperty(
                    k, buildNodeFromCodeUnit(v)
                )
            );
        }
        else if (isObject(v)) {
            properties.push(
                buildProperty(
                    k, buildNodeFromObject(v)
                )
            );
        }
        else if (isArray(v)) {
            properties.push(
                buildProperty(
                    k, buildArrayNodeFromArray(v)
                )
            );
        }
    }
    return b.objectExpression(properties);
}





